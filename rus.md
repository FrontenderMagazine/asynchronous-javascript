<section class="post-content">

![asynchronous-javascript-cover][1]

До `async` функций — подать рукой, однако, пройденный до них путь нельзя назвать близким.
Кажется, еще недавно мы просто писали [коллбеки][2], и вот уже одна за другой появились [спецификация Promise/A+][9], [генераторы][3], а теперь еще и `async`-функции.

Давайте оглянемся и вспомним как на протяжении лет эволюционировал асинхронный JavaScript.


## Коллбеки {#callbacks}

*Все началось с [коллбеков][2].*


### Асинхронный JavaScript {#asynchronousjavascript}

Асинхронное программирование на JavaScript в настоящем виде возможно благодаря функциям-объектам первого класса: их можно передавать в другие функции как обычные переменные.
Коллбеки получаются так: если в одну функцию*(т.н. **функцию высшего порядка**)* в качестве параметра передать другую, её можно будет вызвать по завершении работы.
Никаких *возвращаемых значений* *(return values)*, только передача значений в коллбек.

    Something.save(function(err) {
      if (err) {
        //error handling
        return;
      }
      console.log('success');
    });


Это — так называемые **error-first коллбеки**, они пронизывают Node.js насквозь: их использует как ядро Node, так и большая часть модулей из NPM.

Сложности с коллбеками:

* пользуясь ими неправильно, легко погрязнуть в callback hell или спагетти-коде
* легко пропустить обработку ошибок
* невозможно вернуть значение инструкцией `return`, равно как и использовать `throw`, чтобы сгенерировать ошибку


В основном, по этим причинам JavaScript-коммьюнити начало поиск решений, способных сделать асинхронную разработку проще.

Одним из таких решений был модуль [async][4].
Если вы много работали с коллбеками, то знаете как сложно организовывать параллельное и последовательное выполнение асинхронного кода или преобразование массивов с его помощью.
Для таких случаев [Каоланом Макмахоном][5] был написан модуль async.

Например, с async вы легко можете преобразовывать массивы, при помощи асинхронных функций:

    async.map([1, 2, 3], AsyncSquaringLibrary.square,
      function(err, result){
        // result will be [1, 4, 9]
    });


Тем не менее, читать и писать такой код все еще непросто — и тут на помощь приходят Промисы.


## Промисы {#promises}

Нынешняя спецификация промисов в JavaScript датируется 2012 годом и доступна также в стандарте ES6 — тем не менее, промисы не были изобретением JavaScript-сообщества.
Сам термин был введен [Дэниэлом Фридманом][6] еще в 1976 году.

**Промис представляет собой ожидаемый результат асинхронной операции.**

С Промисами предыдущий пример выглядел бы так:

    Something.save()
      .then(function() {
        console.log('success');
      })
      .catch(function() {
        //error handling
      })


Как вы могли заметить, промисы тоже используют коллбеки.
Как `then`, так и `catch` регистрируют коллбеки, которые будут вызваны с результатом асинхронной операции или причиной, по которой она не может быть выполнена.
Другое замечательное свойство промисов — то, что их можно вызывать по цепочке:

    saveSomething()
      .then(updateOtherthing)
      .then(deleteStuff)
      .then(logResults);


В средах пока еще не поддерживающих промисы нативно можно использовать полифилы.
Популярный выбор в таких случаях — [bluebird][7].
Библиотеки могут предоставлять гораздо большую функциональность, чем нативные промисы, но даже в таких случаях **ограничьтесь возможностями, предоставленными спецификацией Promises/A+**.

Почему не стоит использовать сахарные методы? Почитайте [Promises: The Extension Problem][8], а если хотите узнать о промисах больше, то обратитесь к [спецификации][9].

*Вы спросите: как пользоваться промисами, когда большинство библиотек предоставляют только интерфейс коллбеков?*

Ну, это очень просто: единственное, что надо сделать — это обернуть коллбек, который вызывает исходная функция, в промис:

    function saveToTheDb(value) {
      return new Promise(function(resolve, reject) {
        db.values.insert(value, function(err, user) { // remember error first ;)
          if (err) {
            return reject(err); // don't forget to return here
          }
          resolve(user);
        })
      }
    }


Некоторые библиотеки и фреймворки уже поддерживают и то и другое, предоставляя интерфейс коллбеков и промисов одновременно.
На данный момент, если пишете библиотеку, хорошей практикой будет поддерживать и то и другое.
Вы легко можете сделать это так:

    function foo(cb) {
      if (cb) {
        return cb();
      }
      return new Promise(function (resolve, reject) {
      });
    }


Или даже проще, вы можете начать с интерфейса, построенного исключительно на промисах и предоставить обратную совместимость при помощи такого инструмента как [callbackify][10].
Callbackify в целом, делает то же, что и вышеприведенный код, только в более общем виде.


## Генераторы / yield {#generatorsyield}

[Генераторы][11] — относительно новая концепция, впервые они появились в ES6 *(также известном как ES2015)*.

> Было бы неплохо, выполняя функцию, в любой момент поставить ее на паузу, вычислить что-то еще, сделать что-то другое, и потом вернуться к ней, даже с каким-то значением и продолжить?

Это именно то, что делают функции-генераторы.
Когда вы вызываете генератор, он не начинает выполняться, мы должны будем итерировать по нему вручную.

    function* foo () {
      var index = 0;
      while (index < 2) {
        yield index++;
      }
    }
    var bar = foo();

    console.log(bar.next()); // { value: 0, done: false }
    console.log(bar.next()); // { value: 1, done: false }
    console.log(bar.next()); // { value: undefined, done: true }

Если хотите использовать генераторы для написания асинхронного JavaScript, вам также понадобится [co][12].

> Co — это библиотека управления потоком выполнения для Node.js и браузера, основанная на генераторах, использующая промисы и позволяющая писать неблокирующий код в удобном виде.

С `co` наш предыдущий пример становится таким:

    co(function* (){
      yield Something.save();
    }).then(function() {
      // success
    }).catch(function(err) {
      //error handling
    });


Вы спросите: а как насчет параллельного выполнения операций? Ответ проще, чем вы могли бы подумать *(под капотом это всего лишь `Promise.all`)*:

    yield [Something.save(), Otherthing.save()];


## Async / await {#asyncawait}

Асинхронные функции **(async functions)** появились в ES7 и сейчас доступны только в транспайлерах, таких как [babel][13]. *(прим.: сейчас мы говорим о ключевом слове `async`, а не о библиотеке)*

Вкратце, при помощи ключевого слова `async` мы можем делать то же, что и с комбинацией `co` и генераторов, только без хаков.

![denicola-yield-await-asynchronous-javascript][14]

Под капотом `async`-функции используют промисы — вот почему асинхронные функции возвращают `промис`.

Так что, если мы хотим сделать то же, что и в предыдущих примерах, мы могли бы привести сниппет к следующему виду:

    async function save(Something) {
      try {
        await Something.save()
      } catch (ex) {
        //error handling
      }
      console.log('success');
    }


Как видите, чтобы использовать асинхронную функцию, вы должны написать ключевое слово `async` перед объявлением функции.
После этого вы можете использовать ключевое слово `await` внутри свежесозданной асинхронной функции.

Запуск параллельного кода с `async`-функциями довольно близок к подходу с `yield` кроме того, что `Promise.all` вызывается явно:

    async function save(Something) {
      await Promise.all[Something.save(), Otherthing.save()]
    }


[Koa][15] уже поддерживает `async`-функции, так что вы можете попробовать их уже сегодня при помощи `babel`.

    import koa from koa;
    let app = koa();

    app.experimental = true;

    app.use(async function (){
      this.body = await Promise.resolve('Hello Reader!')
    })

    app.listen(3000);


## Дальнейшее чтение {#furtherreading}

Сейчас в продакшене большинства наших новых проектов, мы используем [Koa][11] и [Hapi с генераторами][3].

> Какой из вариантов вы предпочитаете? Почему? Я был бы рад услышать комментарии!
</section>

 [1]: img/the-evolution-of-asynchronous-javascript.png
 [2]: https://blog.risingstack.com/node-js-best-practices/
 [3]: https://blog.risingstack.com/hapi-on-steroids-using-generator-functions-with-hapi/
 [4]: https://www.npmjs.com/package/async
 [5]: https://twitter.com/caolan
 [6]: https://en.wikipedia.org/wiki/Daniel_P._Friedman
 [7]: https://github.com/petkaantonov/bluebird
 [8]: http://blog.getify.com/promises-part-4/
 [9]: https://promisesaplus.com/
 [10]: https://www.npmjs.com/package/callbackify
 [11]: https://blog.risingstack.com/introduction-to-koa-generators/
 [12]: https://www.npmjs.com/package/co
 [13]: http://babeljs.io
 [14]: img/denicola-yield-await-asynchronous-javascript.JPG
 [15]: http://koajs.com/
